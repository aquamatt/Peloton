<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../xslt/ajax-s-html.xml"?>
<ajax-s>
	<pages>
    <page>
        <h2 id='coverTitle'>Using Python and Twisted in a distributed computing environment</h2>
        <br/>
        <h3>Matthew Pontefract</h3>
        <b>Moving Picture Company</b>
        <p/>
        <p>
	  <a href='mailto:matthew-p@moving-picture.com'>matthew-p@moving-picture.com</a>
	</p>
    </page>
		<page>
			<h2>Twisted, Python and Visual Effects</h2>
			<p>
				Python and the digital movie industry have a long and happy relationship that is getting closer and stronger.
				Today I'm going to look at how ideas grown from other industries and other development environments found
				form in Soho. I'll discuss:
			</p>
			<ul>
				<li>Why I wanted yet another application framework</li>
				<li>The goals of AMANDA, a new Service Application Platform</li>
				<li>Architecture made easy with Twisted and Python</li>
				<li>Application in MPC and elsewhere</li>
				<li>Current challenges and future development</li>
			</ul>
		</page>
		<page>
			<h2>Service frameworks everywhere!</h2>
			<dl>
				<dt>My life in Java</dt>
				<dd>
					<p>
						Until 18 months ago I worked in Java. Frameworks abound and web services with JBoss, WebSphere etc. are easily made.
						<ul>
							<li>JSP provides web scripting/programming</li>
							<li>SOAP and XML-RPC relatively easily supported</li>
							<li>Extensive XML configuration files and many, many layers of abstraction</li>
							<li>Powerful, flexible, but not very dynamic</li> 
						</ul>
					</p>
				</dd>
			</dl>
			
		</page>
		<page>
			<h2>Service frameworks everywhere!</h2>
			<dl>
				<dt>My flirtation with .NET</dt>
				<dd>
					<p>
						A brief daliance with .NET and C# in early 2006 showed that, as in Java, one could fairly easily write web services.
						<ul>
							<li>Web app generation relatively straightforward - gui designers available</li>
							<li>Strong support for SOAP - although life without WSDL seemed to be hard work</li>
							<li>Standard(ish): SOAP is a wonderful world but getting a Python client talking to a C# client (or vice-versa) was not always so easy.</li>
							<li>Easy enough if you follow the one true path...</li>
						</ul>
					</p>
				</dd>
			</dl>
		</page>
		
		<page>
			<h2>Business drivers</h2>
			<ul>
				<li>Need to provide small services, quickly coded, quickly deployed</li>
				<li>Such services need to be accessed from many points, including e.g. Excel and C programs</li>
				<li>Need to link systems together: (originaly trade capture form -&gt; database -&gt; on-line trade execution platform; now 3D modelling app -&gt; render farm -&gt; client FTP site etc.)</li>
				<li>Real-time event processing, feed monitoring</li>
				<li>Computation platform for running models, simulations and embarrassingly parallelisable tasks</li>
			</ul>			
		</page>

		<page>
			<h2>My ideal server platform</h2>			
			<ul>
				<li>Light-weight: servers that start and stop in moments; servers I can debug easily</li>
				<li>Clustering out of the box; distributed computation; resiliance without thinking</li>
				<li>Publishing of methods via any and all protocols - provided by the platform</li>
				<li>Easy scaling: adding computers should instantly increase my application's capacity to handle requests</li>
				<li>Service code written without need to know anything about how it was called</li>
			</ul>
		</page>
    
    <page>
      <h2>My ideal server platform (ctd.)</h2>
      <ul>
        <li>ASSUMES FAILURE</li>
        <li>Easy parallelisation, grid computing-type facilities</li>
        <li>Event-driven tools</li>
        <li>Easy addition of custom protocols to hook up with legacy systems</li>
        <li>A mesh of inhomogenous service providers providing a platform</li>
        <li>Rapid development afforded by Python</li>
      </ul>     
      <p>
        Aspects of all of these requirements can be provided by other frameworks; some do elements of this very well. None seemed to 
        give me the whole suite of functionality in an easy, trivial to manage form.
      </p>
    </page>
		
    <page>
			<h2>The path to MPC</h2>
			<ul>
				<li>Summer 2006: With these ideas in place some proof-of-concept snippets put together: discovered Twisted</li>
				<li>Moved out of finance...</li>
				<li>... moved into MPC</li>
				<li>Upon arrival at MPC found a receptive environment with a large cluster</li>
				<li>... many tightly coupled applications - often coupled at the database </li>
				<li>... lots of os.system() calls</li>
			</ul>
			<p>
				In October 2006 the first implementation of what is now known affectionately as AMANDA came together within a couple of weeks.
			</p>
		</page>		
		<page>
			<h2>Making pictures</h2>
			<p>MPC has  a large R&amp;D department with numerous projects running at infrastructure and imaging level</p>
			<ul>
				<li>A cluster of over 1,500 cores</li>
				<li>Image rendering with procedural generation of assets</li>
				<li>Numerous inter-dependent systems </li>
				<li>24/7 operation</li>
				<li>Many languages: C / C++ / Lua / Python / Perl</li>
        <li>Python the major 'glue' between parts of the pipeline</li>
			</ul>
		</page>
		<page>
			<h2>AMANDA</h2>
			<p>The design concepts built up in previous environments immediately translated to the MPC environment.</p>
			<p>AMANDA provides:</p>
			<ul>
				<li>A mesh of nodes running on one or more physical hosts</li>
				<li>A node runs zero or more services (a service being a Python class) each providing a number of logically related methods</li>
				<li>An event bus: services and clients may fire events and register to receive events (good for very loosely coupled systems with inhomogeneous components and monitoring real-time events)</li>
        <li>Shared session store</li>
				<li>A distributed service platform</li>
				<li>A distributed web application engine (an accidental by-product)</li>
			</ul>
		</page>
		<page>
			<h2>Technology used</h2>			
			<p>Keeping true to UNIX and Python philosophies, AMANDA was built upon other projects:</p>
			<ul>
				<li>Inter-node messaging handled by third party: currently
            <a href='http://activemq.apache.org/'>ActiveMQ</a> and <a href='http://www.spread.org/'>Spread</a> supported</li>
				<li>Shared object store: <a href='http://wiki.zope.org/ZODB/FrontPage'>ZODB</a> + ZEO</li>
				<li><a href='http://www.danga.com/memcached/'>memcached</a>: result cache</li>
				<li>Web templating: <a href='http://genshi.edgewall.org/'>Genshi</a> and <a href='http://www.cheetahtemplate.org/'>Cheetah</a> </li>
				<li>Wire protocols, RPC and web serving: <a href='http://www.twistedmatrix.com/'><b>Twisted</b></a></li>
			</ul>
		</page>
    <page>
        <h2>Other options</h2>
        <ul>
            <li>In January I discovered the <a href='http://www.pythomnic.org'>Pythomnic</a> project</li>
            <li>Similar goals, but different problems tackled</li>
            <li>Network layer written from lower level (no twisted)</li>
            <li>Solved 'reload' problem that allows soft re-starting of services</li>
            <li>Sophisticated solutions to providing distributed transactions</li>
            <li>A lot of communality with each project having different strengths</li>
        </ul>
    </page>
		<page>
			<h2>Mesh topology</h2>			
			<p>A group of AMANDA nodes, each running an arbitrary set of services, collectively form a mesh.</p>
			<ul>
				<li>Requests asked of a node will be passed on to another node if the first cannot handle it. The client is unaware of this (the response is sent back along the same route).</li>
				<li>Failure of a node is noted by downstream nodes that simply re-issue a request to the next available node.</li>
				<li>A scheduler running on one or more nodes in the mesh calls methods at pre-determined times/intervals</li>
			</ul>
			<p>
			The core of the system is a routing class that allows many nodes to pass requests to run methods between each other.
			</p>
      <p>
      Twisted Deferred and remote callable objects provide all the low-level functionality
      out of the box: notification of loss-of-client, passing of results etc.
      </p>
		</page>
    <page>
      <h2>Query-response cycle (1)</h2>
        <img src='images/baseplan.png'/>
    </page>
    <page>
      <h2>A query-response cycle (2)</h2>
      <p>Client calls method on service B via node 1</p>
        <img src='images/scene1.png'/>
    </page>
    <page>
      <h2>A query-response cycle (3)</h2>
      <p>Another client calls method on service B via node 1</p>
        <img src='images/scene2.png'/>
    </page>
    <page>
      <h2>A query-response cycle (4)</h2>
      <p>A third client calls method on service A via node 3</p>
        <img src='images/scene3.png'/>
    </page>
    <page>
      <h2>A query-response cycle (5)</h2>
      <ul>
        <li>All AMANDA nodes provide: <br/>request(service, method, *args, **kargs)</li>
        <li>Client makes a request in a manner that depends on the protocol (examples to come)</li>
        <li>If the node can handle this, the method is executed locally and returned</li>
        <li>If the node cannot handle it, it is passed to a node that can as found in the routing table</li>
        <li>When many providers are available, one is chosen at random (alternate algorithms could be provided).</li>
      </ul>
      <p>
        Twisted Spread is the RPC mechanism used and Deferreds make it easy and efficient to handle responses from upstream nodes efficiently.
      </p>
    </page>       
		<page>
			<h2>Routing requests</h2> 
			<p>A node joining a mesh:</p>
			<ul>
				<li>Broadcast its presence on the message bus</li>
				<li>Receive requests from other nodes to exchange routing tables (details of what services each node provides)</li>
			</ul>
      <p>No node is special in an AMANDA mesh: all communications are symetrical.</p>
			<p>Twisted Spread is the RPC mechanism used to communicate between nodes. Keeping a collection of remote objects and passing deferreds is very much easier than managing related threads.</p>
			<p>A service request is handled in its own thread so that it cannot block the handling of requests. Easy for developers not Twisted-aware.</p>
		</page>
    <page>
        <h2>New node broadcasts presence notification</h2>
        <img src='images/contact1.png'/>
    </page>
    <page>
        <h2>Existing nodes make RPC connection and exchange remote callables</h2>
        <img src='images/contact2.png'/>
    </page>
		<page>
			<h2>Calling AMANDA</h2>
			<p>
				Imagine we have a service with a method as follows:
			</p>
			<pre>
def service_getWeatherForLocation(self, town, day='Monday'):
	wx = self._getWeather(town, day)
	return {'temp': wx.temp, 'vis': wx.vis, 'summary': wx.summary}
			</pre>
			<p>
				An XML client might look like:
			</p>
			<pre>
server = xmlrpclib.Server('http://amanda/xmlrpc')
sessionId = server.login('matthew', 'password')
wx = server.request(sessionId, "WeatherService", \
		"getWeatherForLocation", "London", "Wednesday")
			</pre>
			<p>
				The client receives the dictionary de-serialised into a form appropriate for that platform.
			</p>
		</page>
		<page>
			<h2>Web browsers</h2>
			<p>
				Making a request with a web browser is achieved as follows:
			</p>
			<pre>
http://amandaserver/<b>web</b>/request/WeatherService/getWeatherForLocation\
		/London?day=Wednesday
			</pre>
			<p>
				Path arguments after the method name are converted to positional arguments when making the method call. 
			</p><p>
			Request arguments
				are converted to keyword arguments (POST requests are treated likewise). This will be familiar to many developers in other frameworks such as Turbo Gears.
			</p>
			<p>
				The return value is either stringified or, if a template is placed in an appropriate location, passed to the templating engine for processing.
			</p>
		</page>
		<page>
			<h2>Web browsers (ctd.)</h2>
			<p>
				Wanting a JSON response back for an AJAX call perhaps?
			</p>
			<pre>
http://amandaserver/<b>json</b>/request/WeatherService/getWeatherForLocation \
	/London?day=Wednesday
			</pre>
			<p>
				The return value is formatted into a JSON string.
			</p>
		</page>
    <page>
      <h2>Example web application: Console</h2>
      <p>
        The web control utility is itself an Amanda web-application
      </p>
      <img src='images/info1.png'/>
    </page>
    <page>
      <h2>Example web application: Console (ctd.)</h2>
      <img src='images/info2.png'/>
    </page>
    <page>
      <h2>Example web application: Console Statistics</h2>
      <img src='images/stats1.png'/>
    </page>
    <page>
      <h2>Making asynchronous programming synchronous</h2>
      <ul>
        <li>Sometimes synchronous code is easier to write and understand</li>
        <li>Unless running a Twisted reactor already, asynchronous code is unlikely to fit into an app easily</li>
        <li>When server calls are small and numerous, callback chains can be hard to follow</li>
        <li>Wrapping requests in a mechanism that uses Python Queue objects allows users the choice of pseudo-synchronous operation</li>
      </ul>
    </page>
    <page>
      <h2>Making asynchronous programming synchronous (ctd.)</h2>
      <ul>
        <li>A server request returns a Queue object on which get() may be called - this blocks until the response is put on the Queue; alternatively the response may be polled for by checking the Queue for content or using get(False)</li>
        <li>Twisted event loop is run in a separate thread - all managed by a convenience class</li>
      </ul>
      <pre style='font-size:120%'>
q = server.makeRequest('WeatherService', 'getWeatherForLocation', \
    town='London', day='Tuesday')
wx = <b>q.get()</b>
      </pre>
    </page>
		<page>
			<h2>Events</h2>
			<ul>
				<li>
					Events are small messages broadcast to registered listeners
				</li>
				<li>
					Listeners may be services or AMANDA clients
				</li>
				<li>
					There is a mechanism that allows polling clients (e.g. XMLRPC or Web clients) to retrieve events fired between polls.
				</li>
				<li>
					Events can be used to notify groups of interested parties about something that has happened, or to pass command and control signals to 
					groups of nodes/applications from a single point without needing to make contact with each explicitly.
				</li>
        <li>Events are routed only to the same mesh and are channelised on that mesh (events have a name and are sent on a given channel)</li>
			</ul>
		</page>
		<page>
			<h2>What does this allow us to do?</h2>
			<ul>
				<li>Share methods; publishing them within minutes to be available to all</li>
				<li>Easily broadcast logging information across the network to listening clients</li>
        <li>React to activity in your business code: triggers on events</li>
				<li>Automate reliable data gathering</li>
				<li>Provide bridge to external systems</li>
				<li>Provide links between common systems</li>
			</ul>
		</page>
		<page>
			<h2>Features of a service</h2>
			<ul>	
        <li>Services are totally stateless: any state is stored in a client session (itself an object stored in ZODB)</li>
				<li>Service methods are standard Python methods that return standard Python data</li>
				<li>A suite of decorators provide control over how these are called, including a means of cacheing your
				results with one line of code:
				<pre>@ServiceModule.cache(60)
@ServiceModule.security(5)
def service_helloWorld(self):
	...</pre>
				will cache the result of this call for 60 seconds, return subsequent requests directly from the cache until timed out. The 'security' decorator
				specifies the minimum level of user permitted to call this method.
				</li>
        <li>Access to a service is controlled by a service authorisation engine. Authentication is a mesh-level task.</li>
			</ul>
		</page>
		<page>
			<h2>Features of a mesh</h2>
			<ul>
				<li>Nodes may be added and removed at any time. </li>
        <li>Routing of requests is dynamic</li>
        <li>No particular topology is enforced: simple architecture allows you to choose an appropriate layout for your site and application.</li>
			</ul>
		</page>
    <page>
      <h2>Performance</h2>
      <img src='images/stress.png'/>
      <table>
        <tr>
	  <th>Handlers</th><th>Clients</th><th>Rate</th>
	</tr>
	<tr>
	  <td>1</td><td>1</td><td>3700/min</td>
	</tr>
	<tr>
	  <td>2</td><td>1</td><td>3800/min (2*1900)</td>
	</tr>
	<tr>
	  <td>3</td><td>1</td><td>4300/min (3*1450)</td>
	</tr>
	<tr>
	  <td>3</td><td>100</td><td>13770/min</td>
	</tr>
	<tr>
	  <td>4</td><td>100</td><td>13770/min</td>
	</tr>
      </table>
    </page>
    <page>
      <h2>Performance (ctd.)</h2>
      <ul>
        <li>Adding nodes distributes load very comfortably</li>
	<li>This works for brokers as well</li>
	<li>Dynamic balancing, by adding/removing nodes is possible</li>
	<li>Have tested up to 600 clients with total rate of 30k/min with this test</li>
      </ul>
    </page>
    <page>
      <h2>Resilient mesh layout</h2>
      <p>An AMANDA mesh with several discrete nodes providing the same service is resilient to the failure of service handler nodes. There are more difficult failure modes to handle however:</p>
      <ul>
        <li>Clients have to connect to one node, be it randomly chosen or selected through DNS: if this fails the client needs to handle re-try</li>
        <li>Having dedicated 'broker nodes' doing nothing but routing helps: these are harder to crash</li>
        <li>Using a watchdog to keep the broker nodes alive minimises down-time if a node fails</li>
        <li>A watchdog + Linux IPTables can ensure rapid substitution of working brokers</li>
        <li>Enforced statelessness in AMANDA makes this work considerably easier</li>
      </ul>
    </page>
    
		<page>
			<h2>Current problems</h2>
			<ul>
				<li>We have a couple of issues with Jelly, the Twisted object serialisation system through which almost all our requests pass as they bounce between nodes:
					<ul>
						<li>Having to register proxies for Jellyable objects on both sides of the wire makes it awkward to send anything other than basic data structures</li>
						<li>The 640kb limit for Jelly+Twisted Spread has been a problem with us needing to devise other means of passing large results back to clients</li>
            <li>Slow serialization of certain objects</li>
					</ul>
				</li>
        <li>Authentication and authorisation is implemented but needs more thought.</li>
			</ul>
		</page>
		<page>
			<h2>The future</h2>
			<p>Several ideas remain to be added to the implementation or to be refined.</p>
      <ul>
        <li>Mechanism to push individual methods out to the mesh from client code so as to have them immediately distributed either for the use of that one instance, or for general use. Should largely be possible with current code.</li>
        <li>AMANDA is still a little too node-oriented: the target is 'service' oriented system where one asks the mesh to start nodes to run services rather than explicitly starting nodes.
        </li>    
        <li>Web applications: need to decide where to draw the line - to become a full web app server or hold back and integrate better with TurboGears, Django etc.</li>
	<li>Open-sourcing</li>
      </ul>
		</page>
	</pages>
</ajax-s>
